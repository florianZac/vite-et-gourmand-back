<?php

namespace App\Controller;

use App\Entity\Menu;
use App\Entity\Regime;
use App\Entity\SuiviCommande;
use App\Entity\Theme;
use App\Entity\Allergene;
use App\Entity\Plat;
use App\Repository\AllergeneRepository;
use App\Repository\AvisRepository;
use App\Repository\CommandeRepository;
use App\Repository\MenuRepository;
use App\Repository\PlatRepository;
use App\Repository\RegimeRepository;
use App\Repository\SuiviCommandeRepository;
use App\Repository\ThemeRepository;
use App\Service\MailerService;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Attribute\Route;

/**
 * @author      Florian Aizac
 * @created     25/02/2026
 * @description Gestions des actions d'un employé connecté
 * 
 *  1. getCommandes()        : Afficher toutes les commandes en cours
 *  2. rechercherCommande()  : Rechercher une commande par son numéro de commande
 *  3. changerStatut()       : Modifier le statut d'une commande en respectant le cycle de vie strict
 *  4. getMaterialEnCours()  : Retourne toutes les commandes avec matériel non rendu
 *  5. getMaterielCommande() : Retourne l'état du matériel d'une commande ciblée
 *  6. confirmerRestitution(): Confirme le retour du matériel et le paiement de la pénalité
 *  7. getAvisEnAttente()    : Afficher tous les avis en attente de validation
 *  8. approuverAvis()       : Approuver un avis client
 *  9. refuserAvis()         : Refuser un avis client
 *  10. getAllMenus()        : Retourner la liste de tous les menus
 *  11. getMenuById()        : Retourner un menu par son id
 *  12. createMenu()         : Créer un nouveau menu
 *  13. updateMenu()         : Met à jour un menu par son id
 *  14. deleteMenu()         : Supprimer un menu par son id
 *  15. createTheme()        : Créer un nouveau thème
 *  16. updateTheme()        : Met à jour un thème par son id
 *  17. createRegime()       : Créer un nouveau régime
 *  18. updateRegime()       : Met à jour un régime par son id
 *  19. createAllergene()    : Créer un nouvel allergène
 *  20. updateAllergene()    : Met à jour un allergène par son id
 *  21. createPlat()         : Créer un nouveau plat
 *  22. updatePlat()         : Met à jour un plat par son id
 *  23. deletePlat()         : Supprimer un plat par son id
 */

#[Route('/api/employe')]
final class EmployeController extends AbstractController
{
    // =========================================================================
    // COMMANDES
    // =========================================================================

    /**
     * @description Afficher toutes les commandes en cours
     * @param CommandeRepository $commandeRepository Le repository des commandes
     * @return JsonResponse
     */
    #[Route('/commandes', name: 'api_employe_commandes', methods: ['GET'])]
    public function getCommandes(CommandeRepository $commandeRepository): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer toutes les commandes en cours
        $commandes = $commandeRepository->findCommandesEnCours();

        // Étape 3 - Retourner les commandes en JSON
        return $this->json(['status' => 'Succès', 'commandes' => $commandes]);
    }

    /**
     * @description Rechercher une commande par son numéro de commande
     * @param string $nom Le numéro de commande à rechercher
     * @param CommandeRepository $commandeRepository Le repository des commandes
     * @return JsonResponse
     */
    #[Route('/commandes/recherche/{nom}', name: 'api_employe_commandes_recherche', methods: ['GET'])]
    public function rechercherCommande(string $nom, CommandeRepository $commandeRepository): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Rechercher la commande par son numéro
        $commandes = $commandeRepository->findByNumeroCommande($nom);

        // Étape 3 - Si aucune commande trouvée
        if (empty($commandes)) {
            return $this->json(['status' => 'Erreur', 'message' => 'Aucune commande trouvée'], 404);
        }

        // Étape 4 - Retourner les commandes en JSON
        return $this->json(['status' => 'Succès', 'commandes' => $commandes]);
    }

    /**
     * @description Modifier le statut d'une commande en respectant le cycle de vie strict
     * Cycle autorisé : En attente → Acceptée → En préparation → En livraison → Terminée
     * Un retour en arrière est interdit.
     * @param int $id L'id de la commande
     * @param Request $request La requête HTTP contenant le nouveau statut
     * @param CommandeRepository $commandeRepository Le repository des commandes
     * @param EntityManagerInterface $em L'EntityManager
     * @param MailerService $mailerService Le service d'envoi d'emails
     * @return JsonResponse
     */
    #[Route('/commandes/{id}/statut', name: 'api_employe_commande_statut', methods: ['POST'])]
    public function changerStatut(
        int $id,
        Request $request,
        CommandeRepository $commandeRepository,
        SuiviCommandeRepository $suiviCommandeRepository,
        EntityManagerInterface $em,
        MailerService $mailerService
    ): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer la commande
        $commande = $commandeRepository->find($id);
        if (!$commande) {
            return $this->json(['status' => 'Erreur', 'message' => 'Commande non trouvée'], 404);
        }

        // Étape 3 - Récupérer le nouveau statut depuis le JSON
        $data = json_decode($request->getContent(), true);
        $nouveauStatut = $data['statut'] ?? null;

        if (!$nouveauStatut) {
            return $this->json(['status' => 'Erreur', 'message' => 'Statut obligatoire'], 400);
        }

        // Étape 4 - Vérifier le cycle de vie strict
        $ordreStatuts = [
            'En attente'                    => 1,
            'Acceptée'                      => 2,
            'En préparation'                => 3,
            'En livraison'                  => 4,
            'Livré'                         => 5,
            'En attente du retour matériel' => 6,
            'Terminée'                      => 7,
        ];

        // Étape 5 - Vérifier que le nouveau statut existe
        if (!isset($ordreStatuts[$nouveauStatut])) {
            return $this->json(['status' => 'Erreur', 'message' => 'Statut invalide'], 400);
        }

        // Étape 6 -  Vérifier qu'on n'essaie pas de revenir en arrière
        // PROBLEME DETECTER  il devrait etre impossible de changer de statut si le materiel n'est pas restituer
        // mais du coup on doit creer une fonction get et set restitution pour employé et admin ? 
        // a reflechir
        $statutActuel = $commande->getStatut();
        if (isset($ordreStatuts[$statutActuel]) && $ordreStatuts[$nouveauStatut] <= $ordreStatuts[$statutActuel]) {
            return $this->json(['status' => 'Erreur', 'message' => 'Retour en arrière interdit dans le cycle de vie'], 400);
        }

        // Étape 7 - Mettre à jour le statut de la commande
        $commande->setStatut($nouveauStatut);

        // Étape 8 - Créer un suivi de commande
        $suivi = new SuiviCommande();
        $suivi->setStatut($nouveauStatut);
        $suivi->setDateStatut(new \DateTime());
        $suivi->setCommande($commande);
        $em->persist($suivi);

        // Étape 9 - Envoyer un email selon le statut
        $client = $commande->getUtilisateur();
        if ($nouveauStatut === 'Acceptée') {
            $mailerService->sendCommandeAccepteeEmail($client, $commande);
        } elseif ($nouveauStatut === 'En livraison') {
            $mailerService->sendCommandeLivraisonEmail($client, $commande);
        } elseif ($nouveauStatut === 'Livré') {
            // SI pret_materiel == true "En attente du retour matériel" + mail
            if ($commande->isPretMateriel() === true) {
                $commande->setStatut('En attente du retour matériel');
                $mailerService->sendRetourMaterielEmail($client, $commande);
            }
        } elseif ($nouveauStatut === 'Terminée') {
            $mailerService->sendCommandeTermineeEmail($client, $commande);
        }
        // Étape 10 - Sauvegarder en base
        $em->flush();

        // Étape 11 - Retourner un message de confirmation
        // getStatut() retourne le vrai statut final de la commande
        // si pret_materiel == true -> "En attente du retour matériel"
        // sinon -> le statut demandé par l'employé
        return $this->json([
            'status'  => 'Succès',
            'message' => 'Statut mis à jour : ' . $commande->getStatut()
        ]);
    }

    /**
     * @description Retourne toutes les commandes avec matériel non rendu
     * Cible les commandes où :
     *  pret_materiel == true (matériel prêté)
     *  restitution_materiel == false (pas encore rendu)
     *  statut == "En attente du retour matériel"
     * @param CommandeRepository $commandeRepository Le repository des commandes
     * @return JsonResponse
     */
    #[Route('/commandes/materiels-en-cours', name: 'api_employe_materiels_en_cours', methods: ['GET'])]
    public function getMaterialEnCours(CommandeRepository $commandeRepository): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer toutes les commandes avec matériel non rendu
        $commandes = $commandeRepository->findCommandesMaterielARelancer();

        // Étape 3 - Retourner les commandes en JSON
        return $this->json([
            'status'    => 'Succès',
            'total'     => count($commandes),
            'commandes' => $commandes
        ]);
    }

    /**
     * @description Retourne l'état du matériel d'une commande ciblée
     * Permet à l'employé ou l'admin de voir :
     *  si le matériel a été prêté (pret_materiel)
     *  si le matériel a été rendu (restitution_materiel)
     *  si le mail de pénalité a été envoyé (mail_penalite_envoye)
     * @param int $id L'id de la commande
     * @param CommandeRepository $commandeRepository Le repository des commandes
     * @return JsonResponse
     */
    #[Route('/commandes/{id}/materiel', name: 'api_employe_materiel_show', methods: ['GET'])]
    public function getMaterielCommande(int $id, CommandeRepository $commandeRepository): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer la commande par son id
        $commande = $commandeRepository->find($id);
        if (!$commande) {
            return $this->json(['status' => 'Erreur', 'message' => 'Commande non trouvée'], 404);
        }

        // Étape 3 - Retourner uniquement les infos liées au matériel
        return $this->json([
            'status'                => 'Succès',
            'numero_commande'       => $commande->getNumeroCommande(),
            'pret_materiel'         => $commande->isPretMateriel(),
            'restitution_materiel'  => $commande->isRestitutionMateriel(),
            'mail_penalite_envoye'  => $commande->isMailPenaliteEnvoye(),
            'statut'                => $commande->getStatut(),
        ]);
    }

    /**
     * @description Confirme le retour du matériel et le paiement de la pénalité
     * Employé ou Admin coche sur le front :
     *  "matériel rendu" -> restitution_materiel = true
     *  "pénalité payée" -> confirmé via le JSON
     * Une fois les deux confirmés -> commande passe automatiquement à "Terminée"
     * Corps JSON attendu : { "restitution_materiel": true, "penalite_payee": true }
     * @param int $id L'id de la commande
     * @param Request $request La requête HTTP contenant les données au format JSON
     * @param CommandeRepository $commandeRepository Le repository des commandes
     * @param EntityManagerInterface $em L'EntityManager
     * @param MailerService $mailerService Le service d'envoi d'emails
     * @return JsonResponse
     */
    #[Route('/commandes/{id}/restitution', name: 'api_employe_materiel_restitution', methods: ['PUT'])]
    public function confirmerRestitution(
        int $id,
        Request $request,
        CommandeRepository $commandeRepository,
        EntityManagerInterface $em,
        MailerService $mailerService
    ): JsonResponse {

        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer la commande
        $commande = $commandeRepository->find($id);
        if (!$commande) {
            return $this->json(['status' => 'Erreur', 'message' => 'Commande non trouvée'], 404);
        }

        // Étape 3 - Vérifier que la commande est bien en attente du retour matériel
        if ($commande->getStatut() !== 'En attente du retour matériel') {
            return $this->json(['status' => 'Erreur', 'message' => 'Cette commande n\'est pas en attente du retour matériel'], 400);
        }

        // Étape 4 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 5 - Vérifier les champs obligatoires
        if (!isset($data['restitution_materiel']) || !isset($data['penalite_payee'])) {
            return $this->json(['status' => 'Erreur', 'message' => 'Les champs restitution_materiel et penalite_payee sont obligatoires'], 400);
        }

        // Étape 6 - Mettre à jour la restitution du matériel
        $commande->setRestitutionMateriel((bool) $data['restitution_materiel']);

        // Étape 7 - Vérifier si les deux conditions sont remplies pour passer en "Terminée"
        // restitution_materiel == true ET penalite_payee == true
        if ($commande->isRestitutionMateriel() === true && (bool) $data['penalite_payee'] === true) {

            // Passage automatique en "Terminée"
            $commande->setStatut('Terminée');

            // Envoi du mail de confirmation au client
            $mailerService->sendCommandeTermineeEmail($commande->getUtilisateur(), $commande);
        }

        // Étape 8 - Sauvegarder en base
        $em->flush();

        // Étape 9 - Retourner une confirmation
        return $this->json([
            'status'               => 'Succès',
            'message'              => $commande->getStatut() === 'Terminée'
                ? 'Matériel rendu et pénalité payée : commande passée en Terminée'
                : 'Informations mises à jour',
            'statut'               => $commande->getStatut(),
            'restitution_materiel' => $commande->isRestitutionMateriel(),
        ]);
    }

    // =========================================================================
    // AVIS
    // =========================================================================

    /**
     * @description Afficher tous les avis en attente de validation
     * @param AvisRepository $avisRepository Le repository des avis
     * @return JsonResponse
     */
    #[Route('/avis', name: 'api_employe_avis', methods: ['GET'])]
    public function getAvisEnAttente(AvisRepository $avisRepository): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer tous les avis en attente
        $avis = $avisRepository->findBy(['statut' => 'en_attente']);

        // Étape 3 - Retourner les avis en JSON
        return $this->json(['status' => 'Succès', 'total' => count($avis), 'avis' => $avis]);
    }

    /**
     * @description Approuver un avis client
     * @param int $id L'id de l'avis
     * @param AvisRepository $avisRepository Le repository des avis
     * @param EntityManagerInterface $em L'EntityManager
     * @return JsonResponse
     */
    #[Route('/avis/{id}/approuver', name: 'api_employe_avis_approuver', methods: ['PUT'])]
    public function approuverAvis(int $id, AvisRepository $avisRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer l'avis
        $avis = $avisRepository->find($id);
        if (!$avis) {
            return $this->json(['status' => 'Erreur', 'message' => 'Avis non trouvé'], 404);
        }

        // Étape 3 - Vérifier que l'avis est en attente
        if ($avis->getStatut() !== 'en_attente') {
            return $this->json(['status' => 'Erreur', 'message' => 'Cet avis n\'est pas en attente'], 400);
        }

        // Étape 4 - Approuver l'avis
        $avis->setStatut('validé');

        // Étape 5 - Sauvegarder en base
        $em->flush();

        // Étape 6 - Retourner un message de confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Avis approuvé avec succès']);
    }

    /**
     * @description Refuser un avis client
     * @param int $id L'id de l'avis
     * @param AvisRepository $avisRepository Le repository des avis
     * @param EntityManagerInterface $em L'EntityManager
     * @return JsonResponse
     */
    #[Route('/avis/{id}/refuser', name: 'api_employe_avis_refuser', methods: ['PUT'])]
    public function refuserAvis(int $id, AvisRepository $avisRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer l'avis
        $avis = $avisRepository->find($id);
        if (!$avis) {
            return $this->json(['status' => 'Erreur', 'message' => 'Avis non trouvé'], 404);
        }

        // Étape 3 - Vérifier que l'avis est en attente
        if ($avis->getStatut() !== 'en_attente') {
            return $this->json(['status' => 'Erreur', 'message' => 'Cet avis n\'est pas en attente'], 400);
        }

        // Étape 4 - Refuser l'avis
        $avis->setStatut('refusé');
        $em->flush();

        // Étape 5 - Retourner un message de confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Avis refusé avec succès']);
    }

    // =========================================================================
    // MENUS
    // =========================================================================

    /**
     * @description Retourner la liste de tous les menus
     * @param MenuRepository $menuRepository Le repository des menus
     * @return JsonResponse
     */
    #[Route('/menus', name: 'api_employe_menus_list', methods: ['GET'])]
    public function getAllMenus(MenuRepository $menuRepository): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer tous les menus
        $menus = $menuRepository->findAll();

        // Étape 3 - Retourner la liste en JSON
        return $this->json(['status' => 'Succès', 'total' => count($menus), 'menus' => $menus]);
    }

    /**
     * @description Retourner un menu par son id
     * @param int $id L'id du menu
     * @param MenuRepository $menuRepository Le repository des menus
     * @return JsonResponse
     */
    #[Route('/menus/{id}', name: 'api_employe_menus_show', methods: ['GET'])]
    public function getMenuById(int $id, MenuRepository $menuRepository): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer le menu par son id
        $menu = $menuRepository->find($id);
        if (!$menu) {
            return $this->json(['status' => 'Erreur', 'message' => 'Menu non trouvé'], 404);
        }

        // Étape 3 - Retourner le menu en JSON
        return $this->json(['status' => 'Succès', 'menu' => $menu]);
    }

    /**
     * @description Créer un nouveau menu
     * Corps JSON attendu : { "titre": "...", "nombre_personne_minimum": 10, "prix_par_personne": 45.00,
     *                        "description": "...", "quantite_restante": 50, "regime_id": 2, "theme_id": 3,
     *                        "plats": [1, 4, 7] }
     * @param Request $request La requête HTTP contenant les données au format JSON
     * @param MenuRepository $menuRepository Le repository des menus
     * @param PlatRepository $platRepository Le repository des plats
     * @param RegimeRepository $regimeRepository Le repository des régimes
     * @param ThemeRepository $themeRepository Le repository des thèmes
     * @param EntityManagerInterface $em L'EntityManager pour gérer les opérations de base de données
     * @return JsonResponse
     */
    #[Route('/menus', name: 'api_employe_menus_create', methods: ['POST'])]
    public function createMenu(
        Request $request,
        MenuRepository $menuRepository,
        PlatRepository $platRepository,
        RegimeRepository $regimeRepository,
        ThemeRepository $themeRepository,
        EntityManagerInterface $em
    ): JsonResponse {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 3 - Vérifier les champs obligatoires
        $champsObligatoires = ['titre', 'nombre_personne_minimum', 'prix_par_personne', 'description', 'quantite_restante', 'regime_id', 'theme_id'];
        foreach ($champsObligatoires as $champ) {
            if (!isset($data[$champ]) || $data[$champ] === '') {
                return $this->json(['status' => 'Erreur', 'message' => "Le champ $champ est obligatoire"], 400);
            }
        }

        // Étape 4 - Vérifier que le titre n'existe pas déjà
        $existant = $menuRepository->findOneBy(['titre' => $data['titre']]);
        if ($existant) {
            return $this->json(['status' => 'Erreur', 'message' => 'Un menu avec ce titre existe déjà'], 409);
        }

        // Étape 5 - Récupérer le régime 
        $regime = $regimeRepository->find($data['regime_id']);
        if (!$regime) {
            return $this->json(['status' => 'Erreur', 'message' => 'Régime non trouvé'], 404);
        }

        // Étape 6 - Récupérer le thème
        $theme = $themeRepository->find($data['theme_id']);
        if (!$theme) {
            return $this->json(['status' => 'Erreur', 'message' => 'Thème non trouvé'], 404);
        }

        // Étape 7 - Créer le menu
        $menu = new Menu();
        $menu->setTitre($data['titre']);
        $menu->setNombrePersonneMinimum((int) $data['nombre_personne_minimum']);
        $menu->setPrixParPersonne((float) $data['prix_par_personne']);
        $menu->setDescription($data['description']);
        $menu->setQuantiteRestante((int) $data['quantite_restante']);
        $menu->setRegime($regime);
        $menu->setTheme($theme);

        // Étape 8 - Associer les plats si fournis
        if (!empty($data['plats']) && is_array($data['plats'])) {
            foreach ($data['plats'] as $platId) {
                $plat = $platRepository->find($platId);
                if (!$plat) {
                    return $this->json(['status' => 'Erreur', 'message' => "Plat id $platId non trouvé"], 404);
                }
                $menu->addPlat($plat);
            }
        }

        // Étape 9 - Persister le menu
        $em->persist($menu);
        
        // Étape 10 - Sauvegarder
        $em->flush();

        // Étape 11 - Retourner une confirmation avec l'id créé
        return $this->json(['status' => 'Succès', 'message' => 'Menu créé avec succès', 'id' => $menu->getId()], 201);
    }

    /**
     * @description Met à jour un menu par son id
     * Les plats envoyés REMPLACENT les anciens
     * @param int $id L'id du menu à modifier
     * @param Request $request La requête HTTP contenant les données au format JSON
     * @param MenuRepository $menuRepository Le repository des menus
     * @param PlatRepository $platRepository Le repository des plats
     * @param RegimeRepository $regimeRepository Le repository des régimes
     * @param ThemeRepository $themeRepository Le repository des thèmes
     * @param EntityManagerInterface $em L'EntityManager pour gérer les opérations de base de données
     * @return JsonResponse
     */
    #[Route('/menus/{id}', name: 'api_employe_menus_update', methods: ['PUT'])]
    public function updateMenu(
        int $id,
        Request $request,
        MenuRepository $menuRepository,
        PlatRepository $platRepository,
        RegimeRepository $regimeRepository,
        ThemeRepository $themeRepository,
        EntityManagerInterface $em
    ): JsonResponse {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 3 - Chercher le menu à modifier
        $menu = $menuRepository->find($id);
        if (!$menu) {
            return $this->json(['status' => 'Erreur', 'message' => 'Menu non trouvé'], 404);
        }

        // Étape 4 - Mise à jour des champs
        if (isset($data['titre'])) {
            $existant = $menuRepository->findOneBy(['titre' => $data['titre']]);
            if ($existant && $existant->getId() !== $menu->getId()) {
                return $this->json(['status' => 'Erreur', 'message' => 'Un menu avec ce titre existe déjà'], 409);
            }
            $menu->setTitre($data['titre']);
        }

        if (isset($data['nombre_personne_minimum'])) {
            $menu->setNombrePersonneMinimum((int) $data['nombre_personne_minimum']);
        }

        if (isset($data['prix_par_personne'])) {
            $menu->setPrixParPersonne((float) $data['prix_par_personne']);
        }

        if (isset($data['description'])) {
            $menu->setDescription($data['description']);
        }

        if (isset($data['quantite_restante'])) {
            $menu->setQuantiteRestante((int) $data['quantite_restante']);
        }

        // Étape 5 - Mettre à jour le régime si fourni
        if (isset($data['regime_id'])) {
            $regime = $regimeRepository->find($data['regime_id']);
            if (!$regime) {
                return $this->json(['status' => 'Erreur', 'message' => 'Régime non trouvé'], 404);
            }
            $menu->setRegime($regime);
        }

        // Étape 6 - Mettre à jour le thème si fourni
        if (isset($data['theme_id'])) {
            $theme = $themeRepository->find($data['theme_id']);
            if (!$theme) {
                return $this->json(['status' => 'Erreur', 'message' => 'Thème non trouvé'], 404);
            }
            $menu->setTheme($theme);
        }

        // Étape 7 - Synchroniser les plats
        if (isset($data['plats']) && is_array($data['plats'])) {
            foreach ($menu->getPlats() as $platExistant) {
                $menu->removePlat($platExistant);
            }
            foreach ($data['plats'] as $platId) {
                $plat = $platRepository->find($platId);
                if (!$plat) {
                    return $this->json(['status' => 'Erreur', 'message' => "Plat id $platId non trouvé"], 404);
                }
                $menu->addPlat($plat);
            }
        }

        // Étape 8 - Sauvegarder
        $em->flush();

        // Étape 9 - Retourner une confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Menu mis à jour avec succès']);
    }

    /**
     * @description Supprimer un menu par son id
     * @param int $id L'id du menu à supprimer
     * @param MenuRepository $menuRepository Le repository des menus
     * @param EntityManagerInterface $em L'EntityManager pour gérer les opérations de base de données
     * @return JsonResponse
     */
    #[Route('/menus/{id}', name: 'api_employe_menus_delete', methods: ['DELETE'])]
    public function deleteMenu(int $id, MenuRepository $menuRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Chercher le menu à supprimer
        $menu = $menuRepository->find($id);
        if (!$menu) {
            return $this->json(['status' => 'Erreur', 'message' => 'Menu non trouvé'], 404);
        }

        // Étape 3 - suppression du menu
        $em->remove($menu);

        // Étape 4 - sauvegarder
        $em->flush();

        // Étape 5 - Retourner une confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Menu supprimé avec succès']);
    }

  
    // =========================================================================
    // THEMES
    // =========================================================================

    /**
     * @description Créer un nouveau thème
     * Corps JSON attendu : { "libelle": "Noël" }
     * @param Request $request La requête HTTP contenant les données au format JSON
     * @param ThemeRepository $themeRepository Le repository des thèmes
     * @param EntityManagerInterface $em L'EntityManager pour gérer les opérations de base de données
     * @return JsonResponse
     */
    #[Route('/themes', name: 'api_employe_themes_create', methods: ['POST'])]
    public function createTheme(Request $request, ThemeRepository $themeRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 3 - Vérifier que le libellé est présent
        if (empty($data['libelle'])) {
            return $this->json(['status' => 'Erreur', 'message' => 'Le libellé est obligatoire'], 400);
        }

        // Étape 4 - Vérifier que le libellé n'existe pas déjà
        $existant = $themeRepository->findOneBy(['libelle' => $data['libelle']]);
        if ($existant) {
            return $this->json(['status' => 'Erreur', 'message' => 'Ce thème existe déjà'], 409);
        }

        // Étape 5 - Créer et persister le nouveau thème
        $theme = new Theme();
        $theme->setLibelle($data['libelle']);
        $em->persist($theme);
        $em->flush();

        // Étape 6 - Retourner une confirmation avec l'id créé
        return $this->json(['status' => 'Succès', 'message' => 'Thème créé avec succès', 'id' => $theme->getId()], 201);
    }

    /**
     * @description Met à jour un thème par son id
     * Corps JSON attendu : { "libelle": "Mariage" }
     * @param int $id L'id du thème à modifier
     * @param Request $request La requête HTTP contenant les données au format JSON
     * @param ThemeRepository $themeRepository Le repository des thèmes
     * @param EntityManagerInterface $em L'EntityManager pour gérer les opérations de base de données
     * @return JsonResponse
     */
    #[Route('/themes/{id}', name: 'api_employe_themes_update', methods: ['PUT'])]
    public function updateTheme(int $id, Request $request, ThemeRepository $themeRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 3 - Chercher le thème à modifier
        $theme = $themeRepository->find($id);
        if (!$theme) {
            return $this->json(['status' => 'Erreur', 'message' => 'Thème non trouvé'], 404);
        }

        // Étape 4 - Mettre à jour le libellé si fourni
        if (isset($data['libelle'])) {
            $existant = $themeRepository->findOneBy(['libelle' => $data['libelle']]);
            if ($existant && $existant->getId() !== $theme->getId()) {
                return $this->json(['status' => 'Erreur', 'message' => 'Ce libellé est déjà utilisé'], 409);
            }
            $theme->setLibelle($data['libelle']);
        }

        // Étape 5 - Sauvegarder
        $em->flush();

        // Étape 6 - Retourner une confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Thème mis à jour avec succès']);
    }

    // =========================================================================
    // REGIMES
    // =========================================================================

    /**
     * @description Créer un nouveau régime
     * Corps JSON attendu : { "libelle": "Végétarien" }
     * @param Request $request La requête HTTP contenant les données au format JSON
     * @param RegimeRepository $regimeRepository Le repository des régimes
     * @param EntityManagerInterface $em L'EntityManager pour gérer les opérations de base de données
     * @return JsonResponse
     */
    #[Route('/regimes', name: 'api_employe_regimes_create', methods: ['POST'])]
    public function createRegime(Request $request, RegimeRepository $regimeRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 3 - Vérifier que le libellé est présent
        if (empty($data['libelle'])) {
            return $this->json(['status' => 'Erreur', 'message' => 'Le libellé est obligatoire'], 400);
        }

        // Étape 4 - Vérifier que le libellé n'existe pas déjà
        $existant = $regimeRepository->findOneBy(['libelle' => $data['libelle']]);
        if ($existant) {
            return $this->json(['status' => 'Erreur', 'message' => 'Ce régime existe déjà'], 409);
        }

        // Étape 5 - Créer le nouveau régime
        $regime = new Regime();
        $regime->setLibelle($data['libelle']);
        $em->persist($regime);
        $em->flush();

        // Étape 6 - Retourner une confirmation avec l'id créé
        return $this->json(['status' => 'Succès', 'message' => 'Régime créé avec succès', 'id' => $regime->getId()], 201);
    }

    /**
     * @description Met à jour un régime par son id
     * Corps JSON attendu : { "libelle": "Vegan" }
     * @param int $id L'id du régime à modifier
     * @param Request $request La requête HTTP contenant les données au format JSON
     * @param RegimeRepository $regimeRepository Le repository des régimes
     * @param EntityManagerInterface $em L'EntityManager pour gérer les opérations de base de données
     * @return JsonResponse
     */
    #[Route('/regimes/{id}', name: 'api_employe_regimes_update', methods: ['PUT'])]
    public function updateRegime(int $id, Request $request, RegimeRepository $regimeRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 3 - Chercher le régime à modifier
        $regime = $regimeRepository->find($id);
        if (!$regime) {
            return $this->json(['status' => 'Erreur', 'message' => 'Régime non trouvé'], 404);
        }

        // Étape 4 - Mettre à jour le libellé si fourni
        if (isset($data['libelle'])) {
            $existant = $regimeRepository->findOneBy(['libelle' => $data['libelle']]);
            if ($existant && $existant->getId() !== $regime->getId()) {
                return $this->json(['status' => 'Erreur', 'message' => 'Ce libellé est déjà utilisé'], 409);
            }
            $regime->setLibelle($data['libelle']);
        }

        // Étape 5 - Sauvegarder
        $em->flush();

        // Étape 6 - Retourner une confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Régime mis à jour avec succès']);
    }

    // =========================================================================
    // ALLERGENES
    // =========================================================================

    /**
     * @description Créer un nouvel allergène
     * Corps JSON attendu : { "libelle": "Gluten" }
     */
    #[Route('/allergenes', name: 'api_employe_allergenes_create', methods: ['POST'])]
    public function createAllergene(Request $request, AllergeneRepository $allergeneRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 3 - Vérifier que le libellé est présent
        if (empty($data['libelle'])) {
            return $this->json(['status' => 'Erreur', 'message' => 'Le libellé est obligatoire'], 400);
        }

        // Étape 4 - Vérifier que le libellé n'existe pas déjà
        $existant = $allergeneRepository->findOneBy(['libelle' => $data['libelle']]);
        if ($existant) {
            return $this->json(['status' => 'Erreur', 'message' => 'Cet allergène existe déjà'], 409);
        }

        // Étape 5 - Créer et persister l'allergène
        $allergene = new Allergene();
        $allergene->setLibelle($data['libelle']);
        $em->persist($allergene);
        $em->flush();

        // Étape 6 - Retourner une confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Allergène créé avec succès', 'id' => $allergene->getId()], 201);
    }

    /**
     * @description Met à jour un allergène par son id
     * Corps JSON attendu : { "libelle": "Lactose" }
     */
    #[Route('/allergenes/{id}', name: 'api_employe_allergenes_update', methods: ['PUT'])]
    public function updateAllergene(int $id, Request $request, AllergeneRepository $allergeneRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 3 - Chercher l'allergène à modifier
        $allergene = $allergeneRepository->find($id);
        if (!$allergene) {
            return $this->json(['status' => 'Erreur', 'message' => 'Allergène non trouvé'], 404);
        }

        // Étape 4 - Mettre à jour le libellé si fourni
        if (isset($data['libelle'])) {
            $existant = $allergeneRepository->findOneBy(['libelle' => $data['libelle']]);
            if ($existant && $existant->getId() !== $allergene->getId()) {
                return $this->json(['status' => 'Erreur', 'message' => 'Ce libellé est déjà utilisé'], 409);
            }
            $allergene->setLibelle($data['libelle']);
        }

        // Étape 5 - Sauvegarder
        $em->flush();

        // Étape 6 - Retourner une confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Allergène mis à jour avec succès']);
    }

    // =========================================================================
    // PLATS
    // =========================================================================

    /**
     * @description Créer un nouveau plat
     * Corps JSON attendu : { "titre_plat": "Bœuf bourguignon", "photo": "boeuf.jpg", "categorie": "Plat", "allergenes": [1, 2] }
     */
    #[Route('/plats', name: 'api_employe_plats_create', methods: ['POST'])]
    public function createPlat(Request $request, PlatRepository $platRepository, AllergeneRepository $allergeneRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 3 - Vérifier les champs obligatoires
        if (empty($data['titre_plat']) || empty($data['photo']) || empty($data['categorie'])) {
            return $this->json(['status' => 'Erreur', 'message' => 'Les champs titre_plat, photo et categorie sont obligatoires'], 400);
        }

        // Étape 4 - Vérifier que le titre n'existe pas déjà
        $existant = $platRepository->findOneBy(['titre_plat' => $data['titre_plat']]);
        if ($existant) {
            return $this->json(['status' => 'Erreur', 'message' => 'Un plat avec ce titre existe déjà'], 409);
        }

        // Étape 5 - Vérifier que la catégorie est valide
        $categoriesValides = ['Entrée', 'Plat', 'Dessert'];
        if (!in_array($data['categorie'], $categoriesValides)) {
            return $this->json(['status' => 'Erreur', 'message' => 'Catégorie invalide (Entrée, Plat, Dessert)'], 400);
        }

        // Étape 6 - Créer le plat
        $plat = new Plat();
        $plat->setTitrePlat($data['titre_plat']);
        $plat->setPhoto($data['photo']);
        $plat->setCategorie($data['categorie']);

        // Étape 7 - Associer les allergènes si fournis
        if (!empty($data['allergenes']) && is_array($data['allergenes'])) {
            foreach ($data['allergenes'] as $allergeneId) {
                $allergene = $allergeneRepository->find($allergeneId);
                if (!$allergene) {
                    return $this->json(['status' => 'Erreur', 'message' => "Allergène id $allergeneId non trouvé"], 404);
                }
                $plat->addAllergene($allergene);
            }
        }

        // Étape 8 - Persister et sauvegarder
        $em->persist($plat);
        $em->flush();

        // Étape 9 - Retourner une confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Plat créé avec succès', 'id' => $plat->getId()], 201);
    }

    /**
     * @description Met à jour un plat par son id
     * Corps JSON attendu : { "titre_plat": "...", "photo": "...", "categorie": "...", "allergenes": [1, 2] }
     */
    #[Route('/plats/{id}', name: 'api_employe_plats_update', methods: ['PUT'])]
    public function updatePlat(int $id, Request $request, PlatRepository $platRepository, AllergeneRepository $allergeneRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 3 - Chercher le plat à modifier
        $plat = $platRepository->find($id);
        if (!$plat) {
            return $this->json(['status' => 'Erreur', 'message' => 'Plat non trouvé'], 404);
        }

        // Étape 4 - Mettre à jour le titre si fourni
        if (isset($data['titre_plat'])) {
            $existant = $platRepository->findOneBy(['titre_plat' => $data['titre_plat']]);
            if ($existant && $existant->getId() !== $plat->getId()) {
                return $this->json(['status' => 'Erreur', 'message' => 'Un plat avec ce titre existe déjà'], 409);
            }
            $plat->setTitrePlat($data['titre_plat']);
        }

        // Étape 5 - Mettre à jour la photo si fournie
        if (isset($data['photo'])) {
            $plat->setPhoto($data['photo']);
        }

        // Étape 6 - Mettre à jour la catégorie si fournie
        if (isset($data['categorie'])) {
            $categoriesValides = ['Entrée', 'Plat', 'Dessert'];
            if (!in_array($data['categorie'], $categoriesValides)) {
                return $this->json(['status' => 'Erreur', 'message' => 'Catégorie invalide (Entrée, Plat, Dessert)'], 400);
            }
            $plat->setCategorie($data['categorie']);
        }

        // Étape 7 - Synchroniser les allergènes si fournis
        if (isset($data['allergenes']) && is_array($data['allergenes'])) {
            foreach ($plat->getAllergenes() as $allergeneExistant) {
                $plat->removeAllergene($allergeneExistant);
            }
            foreach ($data['allergenes'] as $allergeneId) {
                $allergene = $allergeneRepository->find($allergeneId);
                if (!$allergene) {
                    return $this->json(['status' => 'Erreur', 'message' => "Allergène id $allergeneId non trouvé"], 404);
                }
                $plat->addAllergene($allergene);
            }
        }

        // Étape 8 - Sauvegarder
        $em->flush();

        // Étape 9 - Retourner une confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Plat mis à jour avec succès']);
    }

      /**
     * @description Supprimer un plat par son id
     * @param int $id L'id du plat à supprimer
     * @param MenuRepository $menuRepository Le repository des menus
     * @param PlatRepository $platRepository Le repository des plats
     * @param EntityManagerInterface $em L'EntityManager pour gérer les opérations de base de données
     * @return JsonResponse
     */
    // Dans la section PLATS
    #[Route('/plats/{id}', name: 'api_employe_plats_delete', methods: ['DELETE'])]
    public function deletePlat(int $id, PlatRepository $platRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Chercher le plat à supprimer
        $plat = $platRepository->find($id);
        if (!$plat) {
            return $this->json(['status' => 'Erreur', 'message' => 'Plat non trouvé'], 404);
        }
        // Étape 3 - suppression
        $em->remove($plat);

        // Étape 4 - sauvegarder
        $em->flush();

        // Étape 5 - Retourner une confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Plat supprimé avec succès']);
    }

}
