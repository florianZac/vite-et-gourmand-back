<?php

namespace App\Controller;

use App\Entity\Menu;
use App\Entity\MenuImage;
use App\Entity\Regime;
use App\Entity\SuiviCommande;
use App\Entity\Theme;
use App\Entity\Allergene;
use App\Entity\Plat;
use App\Enum\CommandeStatut;

use App\Repository\AllergeneRepository;
use App\Repository\AvisRepository;
use App\Repository\CommandeRepository;
use App\Repository\MenuRepository;
use App\Repository\MenuImageRepository;
use App\Repository\PlatRepository;
use App\Repository\RegimeRepository;
use App\Repository\SuiviCommandeRepository;
use App\Repository\ThemeRepository;
use App\Repository\UtilisateurRepository;

use App\Service\MailerService;

use Doctrine\ORM\EntityManagerInterface;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\File\UploadedFile;
use Symfony\Component\Routing\Attribute\Route;

/**
 * @author      Florian Aizac
 * @created     25/02/2026
 * @description Gestions des actions d'un employé connecté
 * 
 *  1. getCommandes()        : Afficher toutes les commandes en cours
 *  2. rechercherCommande()  : Rechercher une commande par son numéro de commande
 *  3. changerStatut()       : Modifier le statut d'une commande en respectant le cycle de vie strict
 *  4. getMaterialEnCours()  : Retourne toutes les commandes avec matériel non rendu
 *  5. getMaterielCommande() : Retourne l'état du matériel d'une commande ciblée
 *  6. confirmerRestitution(): Confirme le retour du matériel et le paiement de la pénalité
 *  7. filtrerCommandes()    : Filtrer les commandes par statut et/ou par client
 * 
 *  8. getAvisEnAttente()    : Afficher tous les avis en attente de validation
 *  9. approuverAvis()       : Approuver un avis client
 *  10. refuserAvis()        : Refuser un avis client
 * 
 *  11. getAllMenus()        : Retourner la liste de tous les menus
 *  12. getMenuById()        : Retourner un menu par son id
 *  13. createMenu()         : Créer un nouveau menu (avec conditions)
 *  14. updateMenu()         : Met à jour un menu par son id (avec conditions)
 *  15. deleteMenu()         : Supprimer un menu par son id
 * 
 *  16. addImageMenu()       : Ajouter une image à la galerie d'un menu
 *  17. deleteImageMenu()    : Supprimer une image de la galerie d'un menu
 *  18. updateOrdreImage()   : Modifier l'ordre d'affichage d'une image
 * 
 *  19. createTheme()        : Créer un nouveau thème
 *  20. updateTheme()        : Met à jour un thème par son id
 * 
 *  21. createRegime()       : Créer un nouveau régime
 *  22. updateRegime()       : Met à jour un régime par son id
 * 
 *  23. createAllergene()    : Créer un nouvel allergène
 *  24. updateAllergene()    : Met à jour un allergène par son id
 * 
 *  25. createPlat()         : Créer un nouveau plat
 *  26. updatePlat()         : Met à jour un plat par son id
 *  27. deletePlat()         : Supprimer un plat par son id
 * 
 */

#[Route('/api/employe')]
final class EmployeController extends AbstractController
{
    // =========================================================================
    // COMMANDES
    // =========================================================================

    /**
     * @description Afficher toutes les commandes en cours
     * @param CommandeRepository $commandeRepository Le repository des commandes
     * @return JsonResponse
     */
    #[Route('/commandes', name: 'api_employe_commandes', methods: ['GET'])]
    public function getCommandes(CommandeRepository $commandeRepository): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer toutes les commandes en cours
        $commandes = $commandeRepository->findCommandesEnCours();

        // Étape 3 - Retourner les commandes en JSON
        return $this->json(['status' => 'Succès', 'commandes' => $commandes]);
    }

    /**
     * @description Rechercher une commande par son numéro de commande
     * @param string $nom Le numéro de commande à rechercher
     * @param CommandeRepository $commandeRepository Le repository des commandes
     * @return JsonResponse
     */
    #[Route('/commandes/recherche/{nom}', name: 'api_employe_commandes_recherche', methods: ['GET'])]
    public function rechercherCommande(string $nom, CommandeRepository $commandeRepository): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Rechercher la commande par son numéro
        $commandes = $commandeRepository->findByNumeroCommande($nom);

        // Étape 3 - Si aucune commande trouvée
        if (empty($commandes)) {
            return $this->json(['status' => 'Erreur', 'message' => 'Aucune commande trouvée'], 404);
        }

        // Étape 4 - Retourner les commandes en JSON
        return $this->json(['status' => 'Succès', 'commandes' => $commandes]);
    }

    /**
     * @description Modifier le statut d'une commande en respectant le cycle de vie strict
     * Cycle autorisé : En attente -> Acceptée -> En préparation -> En livraison -> Terminée
     * Un retour en arrière est interdit.
     * @param int $id L'id de la commande
     * @param Request $request La requête HTTP contenant le nouveau statut
     * @param CommandeRepository $commandeRepository Le repository des commandes
     * @param EntityManagerInterface $em L'EntityManager
     * @param MailerService $mailerService Le service d'envoi d'emails
     * @return JsonResponse
     */
    #[Route('/commandes/{id}/statut', name: 'api_employe_commande_statut', methods: ['POST'])]
    public function changerStatut(
        int $id,
        Request $request,
        CommandeRepository $commandeRepository,
        SuiviCommandeRepository $suiviCommandeRepository,
        EntityManagerInterface $em,
        MailerService $mailerService
    ): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer la commande
        $commande = $commandeRepository->find($id);
        if (!$commande) {
            return $this->json(['status' => 'Erreur', 'message' => 'Commande non trouvée'], 404);
        }

        // Étape 3 - Récupérer le nouveau statut depuis le JSON
        $data = json_decode($request->getContent(), true);
        $nouveauStatut = $data['statut'] ?? null;

        if (!$nouveauStatut) {
            return $this->json(['status' => 'Erreur', 'message' => 'Statut obligatoire'], 400);
        }

        // Étape 4 - Vérifier le cycle de vie strict
        /*
            VOIR ORDRE DANS commandeStatus.php

        */

        // Étape 5 - Vérifier que le nouveau statut existe
        if (!isset($ordreStatuts[$nouveauStatut])) {
            return $this->json(['status' => 'Erreur', 'message' => 'Statut invalide'], 400);
        }

        // Étape 6 - Vérifier qu'on n'essaie pas de revenir en arrière
        $statutActuel = $commande->getStatut();
        if (isset($ordreStatuts[$statutActuel]) && $ordreStatuts[$nouveauStatut] <= $ordreStatuts[$statutActuel]) {
            return $this->json(['status' => 'Erreur', 'message' => 'Retour en arrière interdit dans le cycle de vie'], 400);
        }

        // Étape 7 - Mettre à jour le statut de la commande
        $commande->setStatut($nouveauStatut);

        // Étape 8 - Créer un suivi de commande pour le statut demandé
        $suivi = new SuiviCommande();
        $suivi->setStatut($nouveauStatut);
        $suivi->setDateStatut(new \DateTime());
        $suivi->setCommande($commande);
        $em->persist($suivi);

        // Étape 9 - Envoyer un email selon le statut
        $client = $commande->getUtilisateur();
        if ($nouveauStatut === 'Acceptée') {
            $mailerService->sendCommandeAccepteeEmail($client, $commande);
        } elseif ($nouveauStatut === 'En livraison') {
            $mailerService->sendCommandeLivraisonEmail($client, $commande);
        } elseif ($nouveauStatut === 'Livré') {
            // Enregistrement automatique de l'heure de livraison
            $commande->setHeureLivraison(new \DateTime());
            // SI pret_materiel == true -> passage automatique en "En attente du retour matériel" + mail
            if ($commande->isPretMateriel() === true) {
                $commande->setStatut('En attente du retour matériel');
                $mailerService->sendRetourMaterielEmail($client, $commande);

                // Créer un second suivi pour le vrai statut final
                $suiviMateriel = new SuiviCommande();
                $suiviMateriel->setStatut('En attente du retour matériel');
                $suiviMateriel->setDateStatut(new \DateTime());
                $suiviMateriel->setCommande($commande);
                $em->persist($suiviMateriel);
            }
        } elseif ($nouveauStatut === 'Terminée') {
            $mailerService->sendCommandeTermineeEmail($client, $commande);
        }

        // Étape 10 - Sauvegarder en base
        $em->flush();

        // Étape 11 - Retourner un message de confirmation
        // getStatut() retourne le vrai statut final de la commande
        // si pret_materiel == true -> "En attente du retour matériel"
        // sinon -> le statut demandé par l'employé
        return $this->json([
            'status'  => 'Succès',
            'message' => 'Statut mis à jour : ' . $commande->getStatut()
        ]);
    }

    /**
     * @description Retourne toutes les commandes avec matériel non rendu
     * Cible les commandes où :
     *  pret_materiel == true (matériel prêté)
     *  restitution_materiel == false (pas encore rendu)
     *  statut == "En attente du retour matériel"
     * @param CommandeRepository $commandeRepository Le repository des commandes
     * @return JsonResponse
     */
    #[Route('/commandes/materiels-en-cours', name: 'api_employe_materiels_en_cours', methods: ['GET'])]
    public function getMaterialEnCours(CommandeRepository $commandeRepository): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer toutes les commandes avec matériel non rendu
        $commandes = $commandeRepository->findCommandesMaterielARelancer();

        // Étape 3 - Retourner les commandes en JSON
        return $this->json([
            'status'    => 'Succès',
            'total'     => count($commandes),
            'commandes' => $commandes
        ]);
    }

    /**
     * @description Retourne l'état du matériel d'une commande ciblée
     * Permet à l'employé ou l'admin de voir :
     *  si le matériel a été prêté (pret_materiel)
     *  si le matériel a été rendu (restitution_materiel)
     *  si le mail de pénalité a été envoyé (mail_penalite_envoye)
     * @param int $id L'id de la commande
     * @param CommandeRepository $commandeRepository Le repository des commandes
     * @return JsonResponse
     */
    #[Route('/commandes/{id}/materiel', name: 'api_employe_materiel_show', methods: ['GET'])]
    public function getMaterielCommande(int $id, CommandeRepository $commandeRepository): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer la commande par son id
        $commande = $commandeRepository->find($id);
        if (!$commande) {
            return $this->json(['status' => 'Erreur', 'message' => 'Commande non trouvée'], 404);
        }

        // Étape 3 - Retourner uniquement les infos liées au matériel
        return $this->json([
            'status'                => 'Succès',
            'numero_commande'       => $commande->getNumeroCommande(),
            'pret_materiel'         => $commande->isPretMateriel(),
            'restitution_materiel'  => $commande->isRestitutionMateriel(),
            'mail_penalite_envoye'  => $commande->isMailPenaliteEnvoye(),
            'statut'                => $commande->getStatut(),
        ]);
    }

    /**
     * @description Confirme le retour du matériel et le paiement de la pénalité
     * Employé ou Admin coche sur le front :
     *  "matériel rendu" -> restitution_materiel = true
     *  "pénalité payée" -> confirmé via le JSON
     * Une fois les deux confirmés -> commande passe automatiquement à "Terminée"
     * Corps JSON attendu : { "restitution_materiel": true, "penalite_payee": true }
     * @param int $id L'id de la commande
     * @param Request $request La requête HTTP contenant les données au format JSON
     * @param CommandeRepository $commandeRepository Le repository des commandes
     * @param EntityManagerInterface $em L'EntityManager
     * @param MailerService $mailerService Le service d'envoi d'emails
     * @return JsonResponse
     */
    #[Route('/commandes/{id}/restitution', name: 'api_employe_materiel_restitution', methods: ['PUT'])]
    public function confirmerRestitution(
        int $id,
        Request $request,
        CommandeRepository $commandeRepository,
        EntityManagerInterface $em,
        MailerService $mailerService
    ): JsonResponse {

        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer la commande
        $commande = $commandeRepository->find($id);
        if (!$commande) {
            return $this->json(['status' => 'Erreur', 'message' => 'Commande non trouvée'], 404);
        }

        // Étape 3 - Vérifier que la commande est bien en attente du retour matériel
        if ($commande->getStatut() !== 'En attente du retour matériel') {
            return $this->json(['status' => 'Erreur', 'message' => 'Cette commande n\'est pas en attente du retour matériel'], 400);
        }

        // Étape 4 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 5 - Vérifier les champs obligatoires
        if (!isset($data['restitution_materiel']) || !isset($data['penalite_payee'])) {
            return $this->json(['status' => 'Erreur', 'message' => 'Les champs restitution_materiel et penalite_payee sont obligatoires'], 400);
        }

        // Étape 6 - Mettre à jour la restitution du matériel
        $commande->setRestitutionMateriel((bool) $data['restitution_materiel']);

        // Étape 7 - Vérifier si les deux conditions sont remplies pour passer en "Terminée"
        // restitution_materiel == true ET penalite_payee == true
        if ($commande->isRestitutionMateriel() === true && (bool) $data['penalite_payee'] === true) {

            // Passage automatique en "Terminée"
            $commande->setStatut('Terminée');

            // Envoi du mail de confirmation au client
            $mailerService->sendCommandeTermineeEmail($commande->getUtilisateur(), $commande);
        }

        // Étape 8 - Sauvegarder en base
        $em->flush();

        // Étape 9 - Retourner une confirmation
        return $this->json([
            'status'               => 'Succès',
            'message'              => $commande->getStatut() === 'Terminée'
                ? 'Matériel rendu et pénalité payée : commande passée en Terminée'
                : 'Informations mises à jour',
            'statut'               => $commande->getStatut(),
            'restitution_materiel' => $commande->isRestitutionMateriel(),
        ]);
    }

    /**
     * @description Filtrer les commandes par statut et/ou par client
     * 
     * @param Request $request La requête HTTP avec les filtres
     * @param CommandeRepository $commandeRepository Le repository des commandes
     * @return JsonResponse
     */
    #[Route('/commandes/filtres', name: 'api_employe_commandes_filtres', methods: ['GET'])]
    public function filtrerCommandes(
        Request $request,
        CommandeRepository $commandeRepository
    ): JsonResponse {

        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer les filtres depuis la query string
        $statut        = $request->query->get('statut');            // ex: ?statut=En attente
        $utilisateurId = $request->query->get('utilisateur_id');    // ex: ?utilisateur_id=3

        // Étape 3 - Convertir utilisateur_id en int si fourni
        $utilisateurId = $utilisateurId !== null ? (int) $utilisateurId : null;

        // Étape 4 - Appeler le repository avec les filtres
        $commandes = $commandeRepository->findByFiltres($statut, $utilisateurId);

        // Étape 5 - Retourner les résultats
        return $this->json([
            'status'   => 'Succès',
            'total'    => count($commandes),
            'filtres'  => [
                'statut'        => $statut        ?? 'tous',
                'utilisateur_id'=> $utilisateurId ?? 'tous',
            ],
            'commandes' => $commandes,
        ]);
    }


    // =========================================================================
    // AVIS
    // =========================================================================

    /**
     * @description Afficher tous les avis en attente de validation
     * @param AvisRepository $avisRepository Le repository des avis
     * @return JsonResponse
     */
    #[Route('/avis', name: 'api_employe_avis', methods: ['GET'])]
    public function getAvisEnAttente(AvisRepository $avisRepository): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer tous les avis en attente
        $avis = $avisRepository->findBy(['statut' => 'en_attente']);

        // Étape 3 - Retourner les avis en JSON
        return $this->json(['status' => 'Succès', 'total' => count($avis), 'avis' => $avis]);
    }

    /**
     * @description Approuver un avis client
     * @param int $id L'id de l'avis
     * @param AvisRepository $avisRepository Le repository des avis
     * @param EntityManagerInterface $em L'EntityManager
     * @return JsonResponse
     */
    #[Route('/avis/{id}/approuver', name: 'api_employe_avis_approuver', methods: ['PUT'])]
    public function approuverAvis(int $id, AvisRepository $avisRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer l'avis
        $avis = $avisRepository->find($id);
        if (!$avis) {
            return $this->json(['status' => 'Erreur', 'message' => 'Avis non trouvé'], 404);
        }

        // Étape 3 - Vérifier que l'avis est en attente
        if ($avis->getStatut() !== 'en_attente') {
            return $this->json(['status' => 'Erreur', 'message' => 'Cet avis n\'est pas en attente'], 400);
        }

        // Étape 4 - Approuver l'avis
        $avis->setStatut('validé');

        // Étape 5 - Sauvegarder en base
        $em->flush();

        // Étape 6 - Retourner un message de confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Avis approuvé avec succès']);
    }

    /**
     * @description Refuser un avis client
     * @param int $id L'id de l'avis
     * @param AvisRepository $avisRepository Le repository des avis
     * @param EntityManagerInterface $em L'EntityManager
     * @return JsonResponse
     */
    #[Route('/avis/{id}/refuser', name: 'api_employe_avis_refuser', methods: ['PUT'])]
    public function refuserAvis(int $id, AvisRepository $avisRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer l'avis
        $avis = $avisRepository->find($id);
        if (!$avis) {
            return $this->json(['status' => 'Erreur', 'message' => 'Avis non trouvé'], 404);
        }

        // Étape 3 - Vérifier que l'avis est en attente
        if ($avis->getStatut() !== 'en_attente') {
            return $this->json(['status' => 'Erreur', 'message' => 'Cet avis n\'est pas en attente'], 400);
        }

        // Étape 4 - Refuser l'avis
        $avis->setStatut('refusé');
        $em->flush();

        // Étape 5 - Retourner un message de confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Avis refusé avec succès']);
    }

    // =========================================================================
    // MENUS
    // =========================================================================

    /**
     * @description Retourner la liste de tous les menus
     * @param MenuRepository $menuRepository Le repository des menus
     * @return JsonResponse
     */
    #[Route('/menus', name: 'api_employe_menus_list', methods: ['GET'])]
    public function getAllMenus(MenuRepository $menuRepository): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer tous les menus
        $menus = $menuRepository->findAll();

        // Étape 3 - Retourner la liste en JSON
        return $this->json(['status' => 'Succès', 'total' => count($menus), 'menus' => $menus]);
    }

    /**
     * @description Retourner un menu par son id
     * @param int $id L'id du menu
     * @param MenuRepository $menuRepository Le repository des menus
     * @return JsonResponse
     */
    #[Route('/menus/{id}', name: 'api_employe_menus_show', methods: ['GET'])]
    public function getMenuById(int $id, MenuRepository $menuRepository): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer le menu par son id
        $menu = $menuRepository->find($id);
        if (!$menu) {
            return $this->json(['status' => 'Erreur', 'message' => 'Menu non trouvé'], 404);
        }

        // Étape 3 - Retourner le menu en JSON
        return $this->json(['status' => 'Succès', 'menu' => $menu]);
    }

    /**
     * @description Créer un nouveau menu
     * Corps JSON attendu : { "titre": "...", "nombre_personne_minimum": 10, "prix_par_personne": 45.00,
     *                        "description": "...", "conditions": "...", "quantite_restante": 50,
     *                        "regime_id": 2, "theme_id": 3, "plats": [1, 4, 7] }
     * @param Request $request La requête HTTP contenant les données au format JSON
     * @param MenuRepository $menuRepository Le repository des menus
     * @param PlatRepository $platRepository Le repository des plats
     * @param RegimeRepository $regimeRepository Le repository des régimes
     * @param ThemeRepository $themeRepository Le repository des thèmes
     * @param EntityManagerInterface $em L'EntityManager pour gérer les opérations de base de données
     * @return JsonResponse
     */
    #[Route('/menus', name: 'api_employe_menus_create', methods: ['POST'])]
    public function createMenu(
        Request $request,
        MenuRepository $menuRepository,
        PlatRepository $platRepository,
        RegimeRepository $regimeRepository,
        ThemeRepository $themeRepository,
        EntityManagerInterface $em
    ): JsonResponse {

        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 3 - Vérifier les champs obligatoires
        $champsObligatoires = ['titre', 'nombre_personne_minimum', 'prix_par_personne', 'description', 'quantite_restante', 'regime_id', 'theme_id'];
        foreach ($champsObligatoires as $champ) {
            if (!isset($data[$champ]) || $data[$champ] === '') {
                return $this->json(['status' => 'Erreur', 'message' => "Le champ $champ est obligatoire"], 400);
            }
        }

        // Étape 4 - Vérifier que le titre n'existe pas déjà
        $existant = $menuRepository->findOneBy(['titre' => $data['titre']]);
        if ($existant) {
            return $this->json(['status' => 'Erreur', 'message' => 'Un menu avec ce titre existe déjà'], 409);
        }

        // Étape 5 - Récupérer le régime 
        $regime = $regimeRepository->find($data['regime_id']);
        if (!$regime) {
            return $this->json(['status' => 'Erreur', 'message' => 'Régime non trouvé'], 404);
        }

        // Étape 6 - Récupérer le thème
        $theme = $themeRepository->find($data['theme_id']);
        if (!$theme) {
            return $this->json(['status' => 'Erreur', 'message' => 'Thème non trouvé'], 404);
        }

        // Étape 7 - Créer le menu
        $menu = new Menu();
        $menu->setTitre($data['titre']);
        $menu->setNombrePersonneMinimum((int) $data['nombre_personne_minimum']);
        $menu->setPrixParPersonne((float) $data['prix_par_personne']);
        $menu->setDescription($data['description']);
        $menu->setQuantiteRestante((int) $data['quantite_restante']);
        $menu->setRegime($regime);
        $menu->setTheme($theme);

        // Étape 7.1 - Conditions du menu (optionnel)
        // Ex: "Commander minimum 14 jours à l'avance. Conserver au frais."
        if (isset($data['conditions'])) {
            $menu->setConditions($data['conditions']);
        }

        // Étape 8 - Associer les plats si fournis
        if (!empty($data['plats']) && is_array($data['plats'])) {
            foreach ($data['plats'] as $platId) {
                $plat = $platRepository->find($platId);
                if (!$plat) {
                    return $this->json(['status' => 'Erreur', 'message' => "Plat id $platId non trouvé"], 404);
                }
                $menu->addPlat($plat);
            }
        }

        // Étape 9 - Persister le menu
        $em->persist($menu);
        
        // Étape 10 - Sauvegarder
        $em->flush();

        // Étape 11 - Retourner une confirmation avec l'id créé
        return $this->json(['status' => 'Succès', 'message' => 'Menu créé avec succès', 'id' => $menu->getId()], 201);
    }

    /**
     * @description Met à jour un menu par son id
     * Les plats envoyés REMPLACENT les anciens
     * @param int $id L'id du menu à modifier
     * @param Request $request La requête HTTP contenant les données au format JSON
     * @param MenuRepository $menuRepository Le repository des menus
     * @param PlatRepository $platRepository Le repository des plats
     * @param RegimeRepository $regimeRepository Le repository des régimes
     * @param ThemeRepository $themeRepository Le repository des thèmes
     * @param EntityManagerInterface $em L'EntityManager pour gérer les opérations de base de données
     * @return JsonResponse
     */
    #[Route('/menus/{id}', name: 'api_employe_menus_update', methods: ['PUT'])]
    public function updateMenu(
        int $id,
        Request $request,
        MenuRepository $menuRepository,
        PlatRepository $platRepository,
        RegimeRepository $regimeRepository,
        ThemeRepository $themeRepository,
        EntityManagerInterface $em
    ): JsonResponse {
        
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 3 - Chercher le menu à modifier
        $menu = $menuRepository->find($id);
        if (!$menu) {
            return $this->json(['status' => 'Erreur', 'message' => 'Menu non trouvé'], 404);
        }

        // Étape 4 - Mise à jour des champs
        if (isset($data['titre'])) {
            $existant = $menuRepository->findOneBy(['titre' => $data['titre']]);
            if ($existant && $existant->getId() !== $menu->getId()) {
                return $this->json(['status' => 'Erreur', 'message' => 'Un menu avec ce titre existe déjà'], 409);
            }
            $menu->setTitre($data['titre']);
        }

        if (isset($data['nombre_personne_minimum'])) {
            $menu->setNombrePersonneMinimum((int) $data['nombre_personne_minimum']);
        }

        if (isset($data['prix_par_personne'])) {
            $menu->setPrixParPersonne((float) $data['prix_par_personne']);
        }

        if (isset($data['description'])) {
            $menu->setDescription($data['description']);
        }

        if (isset($data['quantite_restante'])) {
            $menu->setQuantiteRestante((int) $data['quantite_restante']);
        }

        // Étape 4.1 - Mise à jour des conditions (optionnel)
        // Ex: "Commander minimum 14 jours à l'avance. Conserver au frais."
        if (isset($data['conditions'])) {
            $menu->setConditions($data['conditions']);
        }

        // Étape 5 - Mettre à jour le régime si fourni
        if (isset($data['regime_id'])) {
            $regime = $regimeRepository->find($data['regime_id']);
            if (!$regime) {
                return $this->json(['status' => 'Erreur', 'message' => 'Régime non trouvé'], 404);
            }
            $menu->setRegime($regime);
        }

        // Étape 6 - Mettre à jour le thème si fourni
        if (isset($data['theme_id'])) {
            $theme = $themeRepository->find($data['theme_id']);

            if (!$theme) {
                
                return $this->json(['status' => 'Erreur', 'message' => 'Thème non trouvé'], 404);
            }
            $menu->setTheme($theme);
        }

        // Étape 7 - Synchroniser les plats
        if (isset($data['plats']) && is_array($data['plats'])) {

            foreach ($menu->getPlats() as $platExistant) {

                $menu->removePlat($platExistant);
            }

            foreach ($data['plats'] as $platId) {

                $plat = $platRepository->find($platId);

                if (!$plat) {

                    return $this->json(['status' => 'Erreur', 'message' => "Plat id $platId non trouvé"], 404);
                }
                $menu->addPlat($plat);
            }
        }

        // Étape 8 - Sauvegarder
        $em->flush();

        // Étape 9 - Retourner une confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Menu mis à jour avec succès']);
    }

    /**
     * @description Supprimer un menu par son id
     * La suppression en cascade supprime aussi les images liées (onDelete CASCADE)
     * @param int $id L'id du menu à supprimer
     * @param MenuRepository $menuRepository Le repository des menus
     * @param EntityManagerInterface $em L'EntityManager pour gérer les opérations de base de données
     * @return JsonResponse
     */
    #[Route('/menus/{id}', name: 'api_employe_menus_delete', methods: ['DELETE'])]
    public function deleteMenu(int $id, MenuRepository $menuRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Chercher le menu à supprimer
        $menu = $menuRepository->find($id);
        if (!$menu) {
            return $this->json(['status' => 'Erreur', 'message' => 'Menu non trouvé'], 404);
        }

        // Étape 3 - suppression du menu (cascade supprime aussi les menu_image liées)
        $em->remove($menu);

        // Étape 4 - sauvegarder
        $em->flush();

        // Étape 5 - Retourner une confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Menu supprimé avec succès']);
    }

    // =========================================================================
    // IMAGES MENUS
    // =========================================================================

    /**
     * @description Ajouter une image à la galerie d'un menu
     * Reçoit un fichier image en en plusieurs parties /form-data (PAS en JSON)
     * Sauvegarde le fichier dans public/uploads/menus/
     * Stocke l'URL publique en base dans la table menu_image
     * @see https://www.ibm.com/docs/fr/wm-integration-ipaas?topic=services-support-multipart-request-body
     *
     * Requête en plusieurs parties attendue :
     *   - champ "image"  -> le fichier image (jpg, jpeg, png, webp)
     *   - champ "ordre"  -> position dans la galerie par défaut à 1
     *
     * @param int $id L'id du menu
     * @param Request $request La requête HTTP contenant le fichier uploadé
     * @param MenuRepository $menuRepository Le repository des menus
     * @param EntityManagerInterface $em L'EntityManager
     * @return JsonResponse
     */
    #[Route('/menus/{id}/images', name: 'api_employe_menus_images_add', methods: ['POST'])]
    public function addImageMenu(
        int $id,
        Request $request,
        MenuRepository $menuRepository,
        EntityManagerInterface $em
    ): JsonResponse {

        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer le menu
        $menu = $menuRepository->find($id);
        if (!$menu) {
            return $this->json(['status' => 'Erreur', 'message' => 'Menu non trouvé'], 404);
        }

        // Étape 3 - Récupérer le fichier uploadé
        // $request->files->get('image') lit le fichier depuis le champ "image" de la requête multipart
        // Ce n'est PAS $request->getContent() qui lit le JSON -> ici on lit un fichier binaire
        /** @var UploadedFile|null $fichier */
        $fichier = $request->files->get('image');
        if (!$fichier) {
            return $this->json([
                'status'  => 'Erreur',
                'message' => 'Aucun fichier reçu. Utiliser multipart/form-data avec le champ "image"'
            ], 400);
        }

        // Étape 4 - Vérifier que c'est bien une image acceptée
        $extensionsAutorisees = ['jpg', 'jpeg', 'png', 'webp'];
        $extension = strtolower($fichier->getClientOriginalExtension());
        if (!in_array($extension, $extensionsAutorisees)) {
            return $this->json([
                'status'  => 'Erreur',
                'message' => 'Format invalide. Formats acceptés : jpg, jpeg, png, webp'
            ], 400);
        }

        // Étape 5 - Générer un nom de fichier unique pour éviter les collisions entre menus
        // Exemple de résultat : "menu_3_6a3f2b1c4d5e6789.jpg"
        $nomFichier = 'menu_' . $id . '_' . uniqid() . '.' . $extension;

        // Étape 6 - Déplacer le fichier vers le dossier public/uploads/menus/
        // kernel.project_dir = chemin absolu vers la racine du projet (ex: /var/www/vite-et-gourmand)
        // Le dossier public/ est servi directement par le serveur web
        $dossierUpload = $this->getParameter('kernel.project_dir') . '/public/uploads/menus';
        $fichier->move($dossierUpload, $nomFichier);

        // Étape 7 - Construire l'URL publique accessible depuis le navigateur
        // Le dossier public/ est la racine web -> l'URL commence par /uploads/menus/
        // Exemple : "http://monsite.fr/uploads/menus/menu_3_6a3f2b1c4d5e6789.jpg"
        $urlPublique = '/uploads/menus/' . $nomFichier;

        // Étape 8 - Récupérer l'ordre depuis le champ "ordre" de la requête multipart
        // $request->request->get() lit les champs texte d'une requête multipart (pas JSON)
        // Ordre 1 = photo principale affichée en premier dans la galerie
        $ordre = (int) ($request->request->get('ordre', 1));

        // Étape 9 - Créer l'entité MenuImage et l'associer au menu
        $image = new MenuImage();
        $image->setUrl($urlPublique);
        $image->setOrdre($ordre);
        $image->setMenu($menu);

        // Étape 10 - Persister et sauvegarder
        $em->persist($image);
        $em->flush();

        // Étape 11 - Retourner une confirmation avec l'URL et l'id de l'image créée
        return $this->json([
            'status'  => 'Succès',
            'message' => 'Image ajoutée avec succès',
            'image'   => [
                'id'    => $image->getId(),
                'url'   => $urlPublique,
                'ordre' => $ordre,
            ]
        ], 201);
    }

    /**
     * @description Supprimer une image de la galerie d'un menu
     * Supprime le fichier physique sur le serveur ET l'entrée en base de données
     * @param int $id L'id du menu
     * @param int $imageId L'id de l'image à supprimer
     * @param MenuRepository $menuRepository Le repository des menus
     * @param MenuImageRepository $menuImageRepository Le repository des images
     * @param EntityManagerInterface $em L'EntityManager
     * @return JsonResponse
     */
    #[Route('/menus/{id}/images/{imageId}', name: 'api_employe_menus_images_delete', methods: ['DELETE'])]
    public function deleteImageMenu(
        int $id,
        int $imageId,
        MenuRepository $menuRepository,
        MenuImageRepository $menuImageRepository,
        EntityManagerInterface $em
    ): JsonResponse {

        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer le menu
        $menu = $menuRepository->find($id);
        if (!$menu) {
            return $this->json(['status' => 'Erreur', 'message' => 'Menu non trouvé'], 404);
        }

        // Étape 3 - Récupérer l'image
        $image = $menuImageRepository->find($imageId);
        if (!$image) {
            return $this->json(['status' => 'Erreur', 'message' => 'Image non trouvée'], 404);
        }

        // Étape 4 - Vérifier que l'image appartient bien à ce menu
        // Sécurité : évite qu'un employé supprime une image d'un autre menu via manipulation d'URL
        if ($image->getMenu()->getId() !== $menu->getId()) {
            return $this->json(['status' => 'Erreur', 'message' => 'Cette image n\'appartient pas à ce menu'], 403);
        }

        // Étape 5 - Supprimer le fichier physique sur le serveur
        // L'URL stockée est "/uploads/menus/fichier.jpg" -> on reconstitue le chemin absolu
        $cheminFichier = $this->getParameter('kernel.project_dir') . '/public' . $image->getUrl();
        if (file_exists($cheminFichier)) {
            unlink($cheminFichier);
        }

        // Étape 6 - Supprimer l'entrée en base
        $em->remove($image);
        $em->flush();

        // Étape 7 - Retourner une confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Image supprimée avec succès']);
    }


    /**
     * @description Modifier l'ordre d'affichage d'une image dans la galerie
     * Permet de définir quelle image apparaît en premier (ordre 1 = photo principale)
     * Corps JSON attendu : { "ordre": 2 }
     * @param int $id L'id du menu
     * @param int $imageId L'id de l'image à modifier
     * @param Request $request La requête HTTP contenant le nouvel ordre
     * @param MenuRepository $menuRepository Le repository des menus
     * @param MenuImageRepository $menuImageRepository Le repository des images
     * @param EntityManagerInterface $em L'EntityManager
     * @return JsonResponse
     */
    #[Route('/menus/{id}/images/{imageId}', name: 'api_employe_menus_images_update', methods: ['PUT'])]
    public function updateOrdreImage(
        int $id,
        int $imageId,
        Request $request,
        MenuRepository $menuRepository,
        MenuImageRepository $menuImageRepository,
        EntityManagerInterface $em
    ): JsonResponse {

        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer le menu
        $menu = $menuRepository->find($id);
        if (!$menu) {
            return $this->json(['status' => 'Erreur', 'message' => 'Menu non trouvé'], 404);
        }

        // Étape 3 - Récupérer l'image
        $image = $menuImageRepository->find($imageId);
        if (!$image) {
            return $this->json(['status' => 'Erreur', 'message' => 'Image non trouvée'], 404);
        }

        // Étape 4 - Vérifier que l'image appartient bien à ce menu
        if ($image->getMenu()->getId() !== $menu->getId()) {
            return $this->json(['status' => 'Erreur', 'message' => 'Cette image n\'appartient pas à ce menu'], 403);
        }

        // Étape 5 - Récupérer le nouvel ordre depuis le JSON
        $data = json_decode($request->getContent(), true);
        if (!isset($data['ordre'])) {
            return $this->json(['status' => 'Erreur', 'message' => 'Le champ ordre est obligatoire'], 400);
        }

        // Étape 6 - Mettre à jour l'ordre
        $image->setOrdre((int) $data['ordre']);
        $em->flush();

        // Étape 7 - Retourner une confirmation
        return $this->json([
            'status'  => 'Succès',
            'message' => 'Ordre de l\'image mis à jour avec succès',
            'image'   => [
                'id'    => $image->getId(),
                'url'   => $image->getUrl(),
                'ordre' => $image->getOrdre(),
            ]
        ]);
    }

    // =========================================================================
    // THEMES
    // =========================================================================

    /**
     * @description Créer un nouveau thème
     * Corps JSON attendu : { "libelle": "Noël" }
     * @param Request $request La requête HTTP contenant les données au format JSON
     * @param ThemeRepository $themeRepository Le repository des thèmes
     * @param EntityManagerInterface $em L'EntityManager pour gérer les opérations de base de données
     * @return JsonResponse
     */
    #[Route('/themes', name: 'api_employe_themes_create', methods: ['POST'])]
    public function createTheme(Request $request, ThemeRepository $themeRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 3 - Vérifier que le libellé est présent
        if (empty($data['libelle'])) {
            return $this->json(['status' => 'Erreur', 'message' => 'Le libellé est obligatoire'], 400);
        }

        // Étape 4 - Vérifier que le libellé n'existe pas déjà
        $existant = $themeRepository->findOneBy(['libelle' => $data['libelle']]);
        if ($existant) {
            return $this->json(['status' => 'Erreur', 'message' => 'Ce thème existe déjà'], 409);
        }

        // Étape 5 - Créer et persister le nouveau thème
        $theme = new Theme();
        $theme->setLibelle($data['libelle']);
        $em->persist($theme);
        $em->flush();

        // Étape 6 - Retourner une confirmation avec l'id créé
        return $this->json(['status' => 'Succès', 'message' => 'Thème créé avec succès', 'id' => $theme->getId()], 201);
    }

    /**
     * @description Met à jour un thème par son id
     * Corps JSON attendu : { "libelle": "Mariage" }
     * @param int $id L'id du thème à modifier
     * @param Request $request La requête HTTP contenant les données au format JSON
     * @param ThemeRepository $themeRepository Le repository des thèmes
     * @param EntityManagerInterface $em L'EntityManager pour gérer les opérations de base de données
     * @return JsonResponse
     */
    #[Route('/themes/{id}', name: 'api_employe_themes_update', methods: ['PUT'])]
    public function updateTheme(int $id, Request $request, ThemeRepository $themeRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 3 - Chercher le thème à modifier
        $theme = $themeRepository->find($id);
        if (!$theme) {
            return $this->json(['status' => 'Erreur', 'message' => 'Thème non trouvé'], 404);
        }

        // Étape 4 - Mettre à jour le libellé si fourni
        if (isset($data['libelle'])) {
            $existant = $themeRepository->findOneBy(['libelle' => $data['libelle']]);
            if ($existant && $existant->getId() !== $theme->getId()) {
                return $this->json(['status' => 'Erreur', 'message' => 'Ce libellé est déjà utilisé'], 409);
            }
            $theme->setLibelle($data['libelle']);
        }

        // Étape 5 - Sauvegarder
        $em->flush();

        // Étape 6 - Retourner une confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Thème mis à jour avec succès']);
    }

    // =========================================================================
    // REGIMES
    // =========================================================================

    /**
     * @description Créer un nouveau régime
     * Corps JSON attendu : { "libelle": "Végétarien" }
     * @param Request $request La requête HTTP contenant les données au format JSON
     * @param RegimeRepository $regimeRepository Le repository des régimes
     * @param EntityManagerInterface $em L'EntityManager pour gérer les opérations de base de données
     * @return JsonResponse
     */
    #[Route('/regimes', name: 'api_employe_regimes_create', methods: ['POST'])]
    public function createRegime(Request $request, RegimeRepository $regimeRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 3 - Vérifier que le libellé est présent
        if (empty($data['libelle'])) {
            return $this->json(['status' => 'Erreur', 'message' => 'Le libellé est obligatoire'], 400);
        }

        // Étape 4 - Vérifier que le libellé n'existe pas déjà
        $existant = $regimeRepository->findOneBy(['libelle' => $data['libelle']]);
        if ($existant) {
            return $this->json(['status' => 'Erreur', 'message' => 'Ce régime existe déjà'], 409);
        }

        // Étape 5 - Créer le nouveau régime
        $regime = new Regime();
        $regime->setLibelle($data['libelle']);
        $em->persist($regime);
        $em->flush();

        // Étape 6 - Retourner une confirmation avec l'id créé
        return $this->json(['status' => 'Succès', 'message' => 'Régime créé avec succès', 'id' => $regime->getId()], 201);
    }

    /**
     * @description Met à jour un régime par son id
     * Corps JSON attendu : { "libelle": "Vegan" }
     * @param int $id L'id du régime à modifier
     * @param Request $request La requête HTTP contenant les données au format JSON
     * @param RegimeRepository $regimeRepository Le repository des régimes
     * @param EntityManagerInterface $em L'EntityManager pour gérer les opérations de base de données
     * @return JsonResponse
     */
    #[Route('/regimes/{id}', name: 'api_employe_regimes_update', methods: ['PUT'])]
    public function updateRegime(int $id, Request $request, RegimeRepository $regimeRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 3 - Chercher le régime à modifier
        $regime = $regimeRepository->find($id);
        if (!$regime) {
            return $this->json(['status' => 'Erreur', 'message' => 'Régime non trouvé'], 404);
        }

        // Étape 4 - Mettre à jour le libellé si fourni
        if (isset($data['libelle'])) {
            $existant = $regimeRepository->findOneBy(['libelle' => $data['libelle']]);
            if ($existant && $existant->getId() !== $regime->getId()) {
                return $this->json(['status' => 'Erreur', 'message' => 'Ce libellé est déjà utilisé'], 409);
            }
            $regime->setLibelle($data['libelle']);
        }

        // Étape 5 - Sauvegarder
        $em->flush();

        // Étape 6 - Retourner une confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Régime mis à jour avec succès']);
    }

    // =========================================================================
    // ALLERGENES
    // =========================================================================

    /**
     * @description Créer un nouvel allergène
     * Corps JSON attendu : { "libelle": "Gluten" }
     */
    #[Route('/allergenes', name: 'api_employe_allergenes_create', methods: ['POST'])]
    public function createAllergene(Request $request, AllergeneRepository $allergeneRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 3 - Vérifier que le libellé est présent
        if (empty($data['libelle'])) {
            return $this->json(['status' => 'Erreur', 'message' => 'Le libellé est obligatoire'], 400);
        }

        // Étape 4 - Vérifier que le libellé n'existe pas déjà
        $existant = $allergeneRepository->findOneBy(['libelle' => $data['libelle']]);
        if ($existant) {
            return $this->json(['status' => 'Erreur', 'message' => 'Cet allergène existe déjà'], 409);
        }

        // Étape 5 - Créer et persister l'allergène
        $allergene = new Allergene();
        $allergene->setLibelle($data['libelle']);
        $em->persist($allergene);
        $em->flush();

        // Étape 6 - Retourner une confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Allergène créé avec succès', 'id' => $allergene->getId()], 201);
    }

    /**
     * @description Met à jour un allergène par son id
     * Corps JSON attendu : { "libelle": "Lactose" }
     */
    #[Route('/allergenes/{id}', name: 'api_employe_allergenes_update', methods: ['PUT'])]
    public function updateAllergene(int $id, Request $request, AllergeneRepository $allergeneRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 3 - Chercher l'allergène à modifier
        $allergene = $allergeneRepository->find($id);
        if (!$allergene) {
            return $this->json(['status' => 'Erreur', 'message' => 'Allergène non trouvé'], 404);
        }

        // Étape 4 - Mettre à jour le libellé si fourni
        if (isset($data['libelle'])) {
            $existant = $allergeneRepository->findOneBy(['libelle' => $data['libelle']]);
            if ($existant && $existant->getId() !== $allergene->getId()) {
                return $this->json(['status' => 'Erreur', 'message' => 'Ce libellé est déjà utilisé'], 409);
            }
            $allergene->setLibelle($data['libelle']);
        }

        // Étape 5 - Sauvegarder
        $em->flush();

        // Étape 6 - Retourner une confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Allergène mis à jour avec succès']);
    }

    // =========================================================================
    // PLATS
    // =========================================================================

    /**
     * @description Créer un nouveau plat
     * Corps JSON attendu : { "titre_plat": "Bœuf bourguignon", "photo": "boeuf.jpg", "categorie": "Plat", "allergenes": [1, 2] }
     */
    #[Route('/plats', name: 'api_employe_plats_create', methods: ['POST'])]
    public function createPlat(Request $request, PlatRepository $platRepository, AllergeneRepository $allergeneRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 3 - Vérifier les champs obligatoires
        if (empty($data['titre_plat']) || empty($data['photo']) || empty($data['categorie'])) {
            return $this->json(['status' => 'Erreur', 'message' => 'Les champs titre_plat, photo et categorie sont obligatoires'], 400);
        }

        // Étape 4 - Vérifier que le titre n'existe pas déjà
        $existant = $platRepository->findOneBy(['titre_plat' => $data['titre_plat']]);
        if ($existant) {
            return $this->json(['status' => 'Erreur', 'message' => 'Un plat avec ce titre existe déjà'], 409);
        }

        // Étape 5 - Vérifier que la catégorie est valide
        $categoriesValides = ['Entrée', 'Plat', 'Dessert'];
        if (!in_array($data['categorie'], $categoriesValides)) {
            return $this->json(['status' => 'Erreur', 'message' => 'Catégorie invalide (Entrée, Plat, Dessert)'], 400);
        }

        // Étape 6 - Créer le plat
        $plat = new Plat();
        $plat->setTitrePlat($data['titre_plat']);
        $plat->setPhoto($data['photo']);
        $plat->setCategorie($data['categorie']);

        // Étape 7 - Associer les allergènes si fournis
        if (!empty($data['allergenes']) && is_array($data['allergenes'])) {
            foreach ($data['allergenes'] as $allergeneId) {
                $allergene = $allergeneRepository->find($allergeneId);
                if (!$allergene) {
                    return $this->json(['status' => 'Erreur', 'message' => "Allergène id $allergeneId non trouvé"], 404);
                }
                $plat->addAllergene($allergene);
            }
        }

        // Étape 8 - Persister et sauvegarder
        $em->persist($plat);
        $em->flush();

        // Étape 9 - Retourner une confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Plat créé avec succès', 'id' => $plat->getId()], 201);
    }

    /**
     * @description Met à jour un plat par son id
     * Corps JSON attendu : { "titre_plat": "...", "photo": "...", "categorie": "...", "allergenes": [1, 2] }
     */
    #[Route('/plats/{id}', name: 'api_employe_plats_update', methods: ['PUT'])]
    public function updatePlat(int $id, Request $request, PlatRepository $platRepository, AllergeneRepository $allergeneRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Récupérer les données JSON
        $data = json_decode($request->getContent(), true);

        // Étape 3 - Chercher le plat à modifier
        $plat = $platRepository->find($id);
        if (!$plat) {
            return $this->json(['status' => 'Erreur', 'message' => 'Plat non trouvé'], 404);
        }

        // Étape 4 - Mettre à jour le titre si fourni
        if (isset($data['titre_plat'])) {
            $existant = $platRepository->findOneBy(['titre_plat' => $data['titre_plat']]);
            if ($existant && $existant->getId() !== $plat->getId()) {
                return $this->json(['status' => 'Erreur', 'message' => 'Un plat avec ce titre existe déjà'], 409);
            }
            $plat->setTitrePlat($data['titre_plat']);
        }

        // Étape 5 - Mettre à jour la photo si fournie
        if (isset($data['photo'])) {
            $plat->setPhoto($data['photo']);
        }

        // Étape 6 - Mettre à jour la catégorie si fournie
        if (isset($data['categorie'])) {
            $categoriesValides = ['Entrée', 'Plat', 'Dessert'];
            if (!in_array($data['categorie'], $categoriesValides)) {
                return $this->json(['status' => 'Erreur', 'message' => 'Catégorie invalide (Entrée, Plat, Dessert)'], 400);
            }
            $plat->setCategorie($data['categorie']);
        }

        // Étape 7 - Synchroniser les allergènes si fournis
        if (isset($data['allergenes']) && is_array($data['allergenes'])) {
            foreach ($plat->getAllergenes() as $allergeneExistant) {

                $plat->removeAllergene($allergeneExistant);
            }
            foreach ($data['allergenes'] as $allergeneId) {

                $allergene = $allergeneRepository->find($allergeneId);
                if (!$allergene) {
                    return $this->json(['status' => 'Erreur', 'message' => "Allergène id $allergeneId non trouvé"], 404);
                }
                $plat->addAllergene($allergene);
            }
        }

        // Étape 8 - Sauvegarder
        $em->flush();

        // Étape 9 - Retourner une confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Plat mis à jour avec succès']);
    }
    
    /**
     * @description Supprimer un plat par son id
     * @param int $id L'id du plat à supprimer
     * @param PlatRepository $platRepository Le repository des plats
     * @param EntityManagerInterface $em L'EntityManager pour gérer les opérations de base de données
     * @return JsonResponse
     */
    // Dans la section PLATS
    #[Route('/plats/{id}', name: 'api_employe_plats_delete', methods: ['DELETE'])]
    public function deletePlat(int $id, PlatRepository $platRepository, EntityManagerInterface $em): JsonResponse
    {
        // Étape 1 - Vérifier le rôle EMPLOYE
        if (!$this->isGranted('ROLE_EMPLOYE')) {
            return $this->json(['status' => 'Erreur', 'message' => 'Accès refusé'], 403);
        }

        // Étape 2 - Chercher le plat à supprimer
        $plat = $platRepository->find($id);
        if (!$plat) {
            return $this->json(['status' => 'Erreur', 'message' => 'Plat non trouvé'], 404);
        }

        // Étape 3 - suppression
        $em->remove($plat);

        // Étape 4 - sauvegarder
        $em->flush();

        // Étape 5 - Retourner une confirmation
        return $this->json(['status' => 'Succès', 'message' => 'Plat supprimé avec succès']);
    }
   
}
